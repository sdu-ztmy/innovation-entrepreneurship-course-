# SM2 实现与基准测试

# 1 研究目的与概览

1. 用可读的纯 Python 实现 SM2 曲线与签名流程。
2. 实现并比较 4 种标量乘（scalar multiplication）策略：

   * 基线：仿射坐标 + 二倍-加法（double-and-add）
   * 优化 1：雅可比（Jacobian）坐标下的二倍-加法（避免循环中的模逆）
   * 优化 2：窗口化 wNAF（预计算奇数倍，减少加法次数）
   * 优化 3：蒙哥马利阶梯（Montgomery ladder，常时间 / 抗时序侧信道）
3. 基于多个操作（单次标量乘、密钥生成、公私签名-验签循环）进行定时基准，比较平均耗时。

---

# 2 SM2 域参数与曲线基本概念（背景）

* 使用 SM2 标准（GM/T 0003.5-2012）规定的素数域 $\mathbb{F}_p$、曲线系数 $a,b$、基点 $G=(G_x,G_y)$ 与基点阶 $n$。
* 曲线方程（短 Weierstrass 形式）：

$$
y^2 \equiv x^3 + a x + b \pmod p
$$
* 程序中对基点做了一个基本检查：确认 $G$ 在曲线上（`is_on_curve`）。

> 注：域 $p$ 与阶 $n$ 在实现中均为常量（大整数），运算使用 Python 的大整数运算。

---

# 3 基本算术与表示

### 3.1 模逆（modular inverse）

* 多处需要模逆（division in $\mathbb{F}_p$），实现以快速幂（Fermat）或扩展欧几里得法求逆。
* 注意：使用 $x^{-1} \equiv x^{m-2} \pmod m$ 仅在模 $m$ 为素数时正确；实现里在不同情形会向 `mod_inv` 传入 `p` 或 `n`（要确保两者确实为素数）。

### 3.2 仿射坐标（Affine）

* 点用 $(x,y)$ 表示。
* 加法/倍加公式在仿射下直接使用标准的斜率计算（含除法 → 模逆）。
* 仿射优势：公式直观简洁；劣势：每次加法/倍加通常涉及一次模逆，代价很高（相较于乘法）。

### 3.3 投影/雅可比坐标（Jacobian）

* 雅可比坐标用 $(X,Y,Z)$ 表示仿射点 $(X/Z^2,\, Y/Z^3)$。
* 优点：在加/倍运算中通过代价较小的乘法、平方来替代多数的模逆，只在最后从投影变回仿射时做一次模逆。
* 本实现包含雅可比下的 `jac_double` 与 `jac_add`，并提供 `to_jac`/`to_affine` 的转换。

---

# 4 标量乘算法比较原理

标量乘 $kP$ 是 ECC 的核心操作，实际性能瓶颈主要在加法/倍加的次数与模逆次数。下面逐个解释实现中使用的算法原理、优劣与实现注意点。

### 4.1 基线 — 仿射坐标的二倍-加法

* 算法思想：按二进制扫描标量 $k$，遇 1 做累加（加当前点），每步做一次倍加（重复利用）。
* 实现复杂度：大约需要 $\ell$ 次倍加（$\ell$ 为比特长），平均约 $\ell/2$ 次加法。
* 代价：每次加法/倍加在仿射下均包含模逆 ⇒ 非常昂贵（模逆 >> 乘法）。

### 4.2 优化 — 雅可比坐标下的二倍-加法

* 思路：把双加循环都改到雅可比坐标进行，循环中不做模逆，最后一次转换回仿射时只做一次模逆。
* 代价比较：用更多的乘法/平方换掉模逆，整体速度通常明显快于仿射实现。
* 实现注意：`to_affine` 在循环外只调用一次，确保正确且避免在循环中被误用。

### 4.3 优化 — wNAF

* 基本想法：把 $k$ 用 signed-digit 表示（wNAF），使得非零数字的密度约为 $1/(w+1)$ —— 因此减少加法次数。
* 实现需要预计算基点的若干奇数倍（例如 $P,3P,5P,\dots$ 直到 $2^{w-1}-1$）。
* trade-off：

  * 窗口宽度 $w$ 越大，预计算量与内存越大，但加法次数越少。
  * 预计算适合**固定基点**（如基点 $G$）或重复对同一基点进行大量乘法的场景。对一次性标量乘的收益受限。

### 4.4 蒙哥马利阶梯（Montgomery ladder）

* 结构：为每一位 $k_i$ 做固定模式操作（通常包含一次加法和一次倍加），并用条件交换（cswap）实现分支消除，从而实现**常时间**（constant-time）模式，抵抗简单的时序侧信道。
* 安全性：优点是时间上与标量无关（降低基于时间/分支的密钥恢复风险）。
* 性能注意：

  * 直接用仿射版本实现的蒙阶会依然在每次加法中调用模逆 —— 这样**不是速度优化**，只提升了抗侧信道属性。
  * 真正兼顾性能与常时间的方案是把阶梯实现放在雅可比（或其它投影坐标）上：在循环中避免模逆，仅在结束时一次变回仿射，这样既常时间又高效。
  * 本实现中原先的蒙阶版本为仿射，故未体现出性能提升；可将其替换为雅可比蒙阶以获得“优化 + 常时间”双重优点。

---

# 5 SM2 签名 / 验证流程

### 5.1 ZA 构造

* SM2 在签名前先构造一个扩展杂凑值 ZA，用于把用户 ID 与域参数和公钥绑定进哈希：

ZA = H(ENTL || ID || a || b || G_x || G_y || P_x || P_y)

* 作用：防止域参数或用户标识不一致时的重放/伪造；在实际标准中应使用 SM3，这里为演示用 SHA-256 做占位。

### 5.2 签名

1. 计算 $ZA$，再计算 $e = H(ZA || M)$（模 $n$）。
2. 随机选取临时数（nonce） $k\in[1,n-1]$。
3. 计算 $kG=(x_1,y_1)$。
4. 令 $r \equiv (e + x_1) \bmod n$。若 $r=0$ 或 $r+k \equiv n$ 则需重新选 $k$。
5. 计算

$$
s \equiv (k - r d) \cdot (1 + d)^{-1} \pmod n.
$$

   若 $s=0$ 则需重试。
6. 签名为 $(r,s)$。

> 重要检查点：对 $r,s$ 的范围检验与上面提到的重试条件不可省略（以防签名无效或产生攻击面）。

### 5.3 验证

1. 计算 $ZA$，再 $e = H(ZA || M)$。
2. 检查 $r,s$ 在 $[1,n-1]$ 区间。
3. 令 $t = (r + s) \bmod n$。若 $t=0$ 则验证失败。
4. 计算 $x_1',y_1' = sG + tP$（两个标量乘与一次点加）。
5. 令 $R = (e + x_1') \bmod n$。若 $R = r$ 则签名有效。

---

# 6 基准测试

### 6.1 被测项目

* 单次标量乘法（对随机标量）：衡量核心运算性能。
* 密钥生成（公钥 = d · G）：本质上是一次标量乘。
* 签名 + 验证 循环（完整流程）：包含多个标量乘（签名时的临时 kG、公钥生成/使用等），贴近实际使用场景。

### 6.2 分组策略

* **Baseline（未优化）**：仿射双加。
* **Optimized（优化组）**：雅可比、wNAF、蒙哥马利阶梯。

### 6.3 测量细节

* 每个测量包含若干次“预热”调用（warmup，去除一次性初始化偏差）。
* 使用高精度计时器（`time.perf_counter()`）测量若干次循环并取平均时间（每个测试的循环次数在代码中可配置，例如 scalar: 40 次，sign+verify: 16 次）。
* 报告平均每次耗时（秒或毫秒）。

### 6.4 统计注意

* 平均值有用，但易受异常值影响（建议增加标准差/置信区间报告）。
* 性能受 CPU 频率调节、系统负载、Python 解释器缓存等影响，建议在隔离的环境中多次跑并取中位数/置信区间。

---

# 7 运行结果

![image](https://github.com/sdu-ztmy/innovation-entrepreneurship-course-/new/main/project5/result/1.png)

从测试结果可以看出，未优化的 SM2（仿射坐标+双加）整体性能最差；优化后，雅可比坐标配合双加法的速度提升最明显，标量乘法、密钥生成和签名验证均是最快的方案；wNAF 窗口法相比雅可比坐标慢一些，但仍明显优于未优化版本；蒙哥马利阶梯法在此实现中反而比未优化版本更慢，说明它在该曲线和参数下并未带来预期的性能优势。

# SM2 签名算法误用与私钥恢复实验报告

## 1. 实验原理

### 1.1 SM2 签名流程

1. **密钥生成**：从曲线生成一个随机私钥 `d`，通过椭圆曲线标量乘法得到公钥 `P = dG`；
2. **计算消息摘要**：结合用户标识和公钥信息生成 ZA 值，然后对消息进行哈希得到 `e`；
3. **生成签名**：选取随机数 `k`，计算椭圆曲线点 `kG`，根据公式得到签名 `(r, s)`；
4. **签名验证**：利用公钥及签名值验证消息完整性和签名有效性。

### 1.2 攻击场景

实验中设计了两类典型误用攻击：

#### A. 重复使用同一随机数 `k`

若对不同消息使用同一个 `k`，签名 `(r, s)` 会出现可计算的关系，攻击者可通过已知签名值之间的线性关系，反推出私钥 `d`。

#### B. 已知随机数 `k`

若随机数 `k` 泄露，则可直接利用签名公式反推私钥 `d`，恢复过程简单且确定性高。

### 1.3 私钥恢复原理

* **重复 k 攻击**：利用两个不同消息的签名对 `(r1, s1)` 和 `(r2, s2)`，通过线性方程求解得到私钥 `d`。
* **已知 k 攻击**：利用单条签名及已知 `k`，通过公式直接计算出 `d`。

---

## 2. 实验步骤与过程

1. **密钥生成**：随机生成私钥 `d` 和对应公钥 `P`，验证公钥是否在椭圆曲线上；
2. **PoC-A：重复 k**

   * 对两条消息使用同一个随机数 `k` 生成签名；
   * 验证签名有效性；
   * 利用两条签名恢复私钥 `d`；
   * 对比恢复的私钥与原私钥是否一致，并复原公钥验证一致性。
3. **PoC-B：已知 k**

   * 对一条消息生成签名，同时记录使用的 `k`；
   * 利用已知 `k` 和签名值直接计算私钥 `d`；
   * 对比恢复私钥与原私钥，并复原公钥验证一致性。

---

## 3. 实验结果与分析

1. **PoC-A 重复 k 攻击**

   * 两条不同消息使用同一随机数生成签名，成功恢复出原私钥；
   * 恢复出的私钥可正确复原公钥，与原公钥完全一致。

2. **PoC-B 已知 k 攻击**

   * 一条消息签名的随机数被泄露，可直接计算私钥；
   * 恢复出的私钥同样可复原公钥，验证一致性。

**分析**：实验结果直观地展示了 SM2 在随机数 `k` 使用不当时的严重安全风险。重复 `k` 或泄露 `k` 都会导致私钥泄露，破坏系统的整体安全性。

---

## 4. 安全启示与建议

1. **随机数 `k` 必须唯一且安全生成**，不可重复使用；
2. **私钥保护至关重要**，任何泄露都会导致严重后果；
3. **签名方案实现需谨慎**，推荐使用成熟的密码库以防止低级误用；
4. **对签名过程增加随机性和防护措施**，例如硬件随机数生成器或抗侧信道攻击措施。

---

## 5. 实际运行结果
![image](https://github.com/sdu-ztmy/innovation-entrepreneurship-course-/new/main/project5/result/2.png)

# SM2 重复随机数攻击与签名伪造实验报告

## 1. 实验原理

### 1.1 SM2 签名流程

1. **密钥生成**：随机生成私钥 `d`，通过椭圆曲线点乘得到公钥 `P`；
2. **消息摘要计算**：结合用户标识信息和公钥生成 ZA 值，对消息进行哈希得到 `e`；
3. **签名生成**：随机选择整数 `k`，计算椭圆曲线点 `kG`，再通过公式计算签名 `(r, s)`；
4. **签名验证**：利用公钥和签名值验证消息完整性与签名合法性。

### 1.2 重复 k 攻击原理

在两条消息使用同一随机数 `k` 时，两条签名之间存在可计算的线性关系。攻击者利用两条签名值，通过模运算求解线性方程，即可恢复原始私钥 `d`。

### 1.3 签名伪造

恢复出的私钥可直接用于对任意消息生成合法签名，从而使伪造签名通过原公钥验证，实现对消息的任意签名伪造。

---

## 2. 实验步骤

1. **密钥生成**：随机生成实验私钥 `d` 与公钥 `P`，并验证公钥在曲线上。
2. **选择固定随机数 `k`**：模拟开发失误或实现漏洞导致的重复使用。
3. **生成两条签名**：使用相同 `k` 对两条不同消息生成签名，并验证其合法性。
4. **恢复私钥**：利用两条签名值的线性关系，计算得到原始私钥 `d`。
5. **伪造签名**：使用恢复的私钥对任意消息生成签名，并验证伪造签名是否通过验证。
6. **一致性检查**：通过恢复的私钥重新计算公钥，并与原公钥比对，验证一致性。

---

## 3. 实验结果与分析

1. **重复 k 攻击成功**：

   * 两条消息使用同一随机数生成签名，恢复出的私钥与原私钥完全一致；
   * 利用恢复私钥生成的伪造签名可通过原公钥验证，说明攻击可行。

2. **签名伪造验证**：

   * 实验中对任意消息进行伪造签名，成功通过签名验证，证明恢复私钥具备完全控制权；
   * 恢复私钥对应的公钥与原公钥一致，确认恢复正确性。

**分析**：实验直观显示，SM2 的安全性高度依赖随机数 `k` 的唯一性与保密性。重复或泄露 `k` 会直接导致私钥泄露，从而允许攻击者对任意消息进行签名伪造。

---

## 4. 安全启示

1. **随机数生成必须安全**：每条消息的签名应使用唯一、不可预测的随机数 `k`；
2. **严格保护私钥**：私钥泄露或被推导将完全破坏系统安全；
3. **使用成熟库实现**：避免自制签名实现导致低级错误；
4. **增强防护措施**：可使用硬件随机数生成器或侧信道攻击防护机制，提高系统安全性。

---

## 5. 实际运行结果
![image](https://github.com/sdu-ztmy/innovation-entrepreneurship-course-/new/main/project5/result/3.png)

# SM3哈希算法实现原理详解

## 1. 算法概述
SM3是中国国家密码管理局发布的一种密码哈希算法，属于Merkle-Damgård结构的哈希函数，输出长度为256位(32字节)。该代码实现了SM3算法的多种优化版本。

## 2. 核心组件

### 2.1 基本运算定义
- **循环左移(ROTL)**: 32位字的循环移位操作
- **布尔函数(FF/GG)**: 在不同轮次使用不同的布尔函数组合
- **置换函数(P0/P1)**: 用于消息扩展和压缩函数中的非线性变换
- **常量表(T)**: 64个32位常量，在不同轮次使用

### 2.2 压缩函数
压缩函数是SM3的核心，处理512位(64字节)输入块，主要分为两个阶段：

#### 消息扩展阶段
1. 将512位输入块划分为16个32位字(W[0]-W[15])
2. 通过迭代计算扩展生成68个32位字(W[0]-W[67])
3. 再生成64个32位字(W'[0]-W'[63])用于压缩

#### 压缩阶段
1. 使用8个32位工作变量(A-H)表示中间状态
2. 进行64轮迭代运算，每轮更新工作变量
3. 最终与初始状态异或得到新状态

## 3. 优化策略

### 3.1 基本实现
- 严格按照标准算法流程实现
- 包含完整的消息扩展和压缩过程
- 作为性能比较的基准

### 3.2 优化1：循环展开和常量预计算
- **循环展开**: 将消息扩展的部分循环手动展开，减少循环控制开销
- **批量处理**: 每次处理4个W[i]的计算，提高指令级并行
- **预计算W'**: 提前计算W'数组，减少压缩阶段的重复计算

### 3.3 优化2：查表法优化
- **布尔函数优化**: 尝试使用查表法加速布尔函数计算
- **局限性**: 由于32位操作的限制，实际优化效果有限

### 3.4 优化3：SIMD指令并行化
- **使用AVX2指令集**: 利用128位SIMD寄存器并行处理
- **向量化运算**: 将多个32位运算打包为SIMD操作
- **状态管理**: 使用SIMD寄存器维护算法状态

## 4. 哈希计算流程

1. **消息填充**:
   - 添加bit"1"作为填充起始
   - 填充0直到长度满足(mod 512=448)
   - 最后64位添加原始消息的位长度

2. **分块处理**:
   - 将填充后消息分为512位块
   - 对每个块应用压缩函数
   - 更新哈希状态

3. **输出结果**:
   - 处理完所有块后，将最终状态转为字节序
   - 输出256位(32字节)哈希值

## 5. 性能测试方法

### 5.1 微基准测试
- 对短消息("abc")进行100,000次哈希
- 测量每种实现的单次哈希时间
- 比较不同优化级别的性能差异

### 5.2 吞吐量测试
- 对1MB数据块进行100次哈希
- 计算MB/s吞吐量
- 评估处理大数据量时的性能

## 6. 运行结果
可以观察到效率和占用空间的优化：

![image](https://github.com/sdu-ztmy/innovation-entrepreneurship-course-/blob/main/project4/result/fd231026c0072bb4ef380224edf9f414.png)

# SM3 长度扩展攻击实现原理

## 1. 长度扩展攻击原理

长度扩展攻击利用了哈希算法的以下特性：

### 1.1 Merkle-Damgård 结构弱点
- 哈希状态完全由最终输出值决定
- 知道原始消息长度后可以重建填充
- 可以继续从最终状态计算新消息的哈希

### 1.2 攻击前提条件
1. 知道原始消息的哈希值
2. 知道原始消息的长度
3. 哈希算法采用简单的 secret||message 构造

## 2. 攻击实现步骤

### 2.1 原始哈希计算
1. 计算 `H(secret || message)` 的哈希值
2. 保存最终的状态和消息长度

### 2.2 攻击准备阶段
1. **状态恢复**：从原始哈希值恢复 SM3 的 8 个 32 位状态寄存器
2. **填充重建**：根据原始消息长度计算其填充字节
   - 包含一个 0x80 字节
   - 若干 0x00 字节
   - 8 字节的消息位长度(大端序)

### 2.3 攻击执行阶段
1. **设置计数器**：将 SM3 上下文的字节计数器设为 `原始长度 + 填充长度`
2. **处理扩展**：将攻击者控制的扩展数据作为新消息输入
3. **完成哈希**：执行最终的填充和长度追加，输出伪造哈希

### 2.4 验证阶段
1. 直接计算 `H(secret || message || padding || extension)`
2. 比较攻击结果与直接计算结果
3. 确认两者是否匹配

## 3. 关键实现细节

### 3.1 填充计算
- 精确计算原始消息的填充长度
- 确保填充格式符合 SM3 标准
- 正确处理各种原始消息长度情况

### 3.2 状态管理
- 从哈希值正确恢复内部状态
- 准确设置已处理的字节数
- 维护缓冲区状态的一致性

### 3.3 攻击验证
- 构造完整的消息序列进行直接哈希
- 确保攻击结果与直接计算结果一致
- 处理内存分配和边界条件

## 4. 防御措施

这种攻击的有效性表明：

1. **不安全的 MAC 构造**：`H(secret||message)` 易受攻击
2. **推荐的安全构造**：
   - HMAC 结构
   - `H(secret || message || secret)`
   - 使用专门的消息认证码算法

## 5. 运行结果

可以观察到攻击成功

![image](https://github.com/sdu-ztmy/innovation-entrepreneurship-course-/blob/main/project4/result/897a999ff2403a6b01067c8d825f0750.png)

# Merkle Tree 实现原理详解

## 1. 基本概念

Merkle Tree（默克尔树）是一种二叉树结构，用于高效验证大规模数据的完整性。其核心特点包括：

- **叶子节点**：存储数据块的哈希值
- **非叶子节点**：存储子节点哈希的组合哈希
- **根哈希**：树的顶部哈希，代表整个数据集的指纹

## 2. 实现架构

### 2.1 数据结构设计

- **Hash结构**：封装32字节的SM3哈希值
- **Leaf结构**：存储原始数据和长度
- **MerkleTree结构**：
  - 多层级哈希数组
  - 每层的节点数量记录
  - 总层数记录

### 2.2 核心哈希运算

- **叶子哈希**：`Hash(0x00 || leaf_data)`
- **内部节点哈希**：`Hash(0x01 || left_hash || right_hash)`
- 使用SM3算法作为基础哈希函数

## 3. 树构建过程

### 3.1 预处理阶段

1. **数据排序**：将所有叶子数据按字典序排序
2. **生成叶子哈希**：为每个叶子计算哈希值

### 3.2 层级构建

1. **从叶子层开始**（第0层）
2. **迭代构建上层**：
   - 每两个相邻节点生成一个父节点
   - 处理奇数节点时复制最后一个节点
3. **直到根节点**：最终生成单一根哈希

## 4. 证明机制

### 4.1 包含性证明

**生成过程**：
1. 定位目标叶子在排序后的位置
2. 从叶子到根收集"验证路径"：
   - 每个层级需要的兄弟节点哈希
   - 记录兄弟节点的相对位置（左/右）

**验证过程**：
1. 从叶子哈希开始
2. 按路径依次与兄弟哈希组合计算
3. 最终结果与根哈希比对

### 4.2 非包含性证明

**生成过程**：
1. 查找目标值在排序叶子的插入位置
2. 获取相邻叶子（左邻和/或右邻）
3. 为每个相邻叶子生成包含性证明

**验证过程**：
1. 验证相邻叶子的包含性证明
2. 检查目标值确实位于相邻叶子之间
3. 确认目标值不存在于树中

## 5. 关键技术点

### 5.1 排序保证

- 所有叶子按字典序排列
- 确保非包含性证明的有效性
- 支持高效的二分查找

### 5.2 边界处理

- 奇数节点处理：复制最后一个节点
- 空树情况处理
- 单叶子树特殊情况

### 5.3 内存管理

- 动态分配各级节点存储
- 证明结构的生命周期管理
- 资源释放机制

## 6. 应用场景

1. **区块链**：交易验证
2. **版本控制系统**：文件完整性检查
3. **分布式存储**：数据一致性验证
4. **证书透明化**：证书存在性证明

## 7. 安全特性

- **抗碰撞性**：依赖SM3的安全强度
- **高效验证**：证明复杂度O(log n)
- **完备性**：能证明数据存在和不存在

## 8. 性能考虑

- **批量构建**：一次性构建整个树
- **空间优化**：只存储必要的层级
- **并行潜力**：不同子树可并行计算

 ## 9.运行结果

 可以观察到叶子的存在性证明和不存在性证明都通过：

 ![image](https://github.com/sdu-ztmy/innovation-entrepreneurship-course-/blob/main/project4/result/4a05ce242883dc071347bbd5b32af60d.png)
